import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize

class OptimPort:

    def __init__(self,raw_rets=None,er = None):
        '''
        OptimPort class takes in 2 inputs:
        1. raw_rets: This is the raw returns matrix with shape T*N, where T is the number of rows and N is the number of assets. This is the raw daily returns for the asset class
        2. er: This is our expected returns matrix
        The 2 matrices should be of the same shape
        '''
        self.raw_rets = raw_rets
        self.er = er
        if type(er) ==type(None):
            self.er = raw_rets
        if type(raw_rets) ==type(None):
            self.raw_rets = er

    def calc_port_rets(self,wts):
        '''
        This function calculates the mean returns per asset.
        Input parameters:
        1. wts: Refer to the exposure to each asset in our test
        '''
        wts = np.array (wts)
        return (self.er@wts).mean()

    def calc_port_sharpe(self,wts, freq=252):
        '''
        This function calculates the sharpe ratio of the portfolio.
        1. wts: Weights allocate to each asset
        2. freq: Refers to the periodicity at which we calculate returns
        '''
        rets = self.raw_rets@wts
        return ((rets-mean()/rets.std())*(freq**0.5))

    def calc_port_std(self,wts, cov=None):
        '''
        This function calculates portfolio standard deviation
        Uses [weights transpose * covariance matrix * weights]
        1. cov: Desired covariance matrix, if None, we use the covariance matrix generated by the raw returns
        2. freq: Refers to the periodicity at which we calculate our returns
        '''
        wts = np. array(wts)
        wts = wts.reshape(wts.shape[0],1)
        if type(cov) !=pd.DataFrame:
            cov = self.raw_rets.cov()
        port_std = np.sqrt((wts.T@cov@wts).values[0])
        return port_std

    def get_msr_wts(self,cov=None, riskfree_rate = 0, exposure_constraint=1):
        n = self.raw_rets.shape[1]
        initial_guess = np.repeat(1/n,n)

        if exposure_constraint ==0:
            low_bnd,upp_bnd=-1,1
        elif exposure_constraint ==1:
            low_bnd,upp_bnd = 0,1
        elif exposure_constraint == 1:
            low_bnd, upp_bnd =-1,0
        else:
            low_bnd,upp_bnd = 0,1
        bounds = ((low_bnd,upp_bnd),)*n

        weights_constraint = {'type':'eq',
            'fun':lambda w: np.sum(w)-exposure_constraint
            }


        def neg_sharpe(w, er, cov,riskfree_rate):
            '''Returns the negative of the sharpe ratio of the given portfolio'''
            r = self.calc_port_rets(w)
            vol =self.calc_port_std(w, cov = cov)
            return -(r - riskfree_rate)/vol

        weights = minimize(neg_sharpe,initial_guess,args = (self.er,cov,riskfree_rate),
                            method = "SLSQP",
                            constraints =(weights_constraint),
                            bounds = bounds)

        if exposure_constraint==0 and (sum(weights.x)<-0.05 or sum(weights.x)>0.05 ):
            return np.repeat(0,n)
        return weights.x

    def get_corr_adjustment(self,corr=None):
        '''
        This function gets the correlation adjustment for which will serve as the denominator when 
        we want to adjust our returns prediction for correlation of strategies.
        Inputs:
        1. corr: Correlation matri of our returns series
        '''
        if type(corr) not in [pd.DataFrame,pd.Series,np.array]:
            corr = self.raw_rets.corr()

        for i in range(len(corr)):
            corr.iloc[i,i] = 0
        #Get average of correlation of 1 asset vs the other assets
        corr = corr.sum()/(len(corr)-1)
        #Divide the correlation by the sum of the absolute numbers of all the correlations.
        #This is so that the overall correlation adjustment is still equal to 1 and does not change absolute portfolio exposures
        corr = corr/sum(abs(corr))
        return abs(corr)

    def get_corr_adjusted_weights(self,er = None,corr=None,dollar_neutralize = False):
        if type(corr) not in [pd.DataFrame,pd.Series,np.array]:
            corr = self.raw_rets.corr() 
        if type(er) not in [pd.DataFrame,pd.Series,np.array]:
            #Take weights as expected returns
            weights = self.er 
        else:
            weights = er     
        corr_adjustment = self.get_corr_adjustment(corr)
        weights = weights/corr_adjustment
        if dollar_neutralize == True:
            weights = Implementation(weights).demean_and_delever_weights()

        return weights



class Implementation:
    '''
    The Implementation class incorporates adjustments and changes based on real-life portfolio implementation constraints.
    Class takes in our target position vector wts as its only input
    '''

    def __init__(self,weights):
        self.weights = weights

    def adjust_rebalance(self,threshold):
        if type(weights) not in [pd.DataFrame,pd.Series,np.array]:
            weights = self.weights

        prev = [0] *weights.shape[1]
        weights_cleaned = []
        for i in range(len(weights)):
            wts = []
            temp = weights.iloc[i].values
            for w_i in range(len(temp)):
                if abs(temp[w_i]-prev[w_i])>threshold:
                    wts.append(temp[w_i])
                else:
                    wts.append(prev[w_i])
            weights_cleaned.append(wts)
            prev = wts
        weights_cleaned = pd.DataFrame(weights_cleaned, index = weights.index, columns = weights.columns)
        return weights_cleaned

    def demean_and_delever_weights (self,weights = None):
        '''
        Function dollar neutralizes a given position vector
        First step is to demean the position vector, by subtracting the mean from each asset weight
        Second step is to divide the weights by the sum of the absolute weights
        Inputs:
        1. weights: Position vector; if no input it will take in the weights inputted into the class object
        '''
        if type(weights) not in [pd.DataFrame,pd.Series,np.array]:
            weights = self.weights
        mean_wts = weights.mean(axis=1)

        def subtract_series(weights):
            return weights - mean_wts
        weights = weights.apply(lambda x: subtract_series(x))       

        abs_w = abs(weights).sum(axis = 1) 
        def constraint_abs_wts(weights):
            return weights/abs_w
        weights = weights.apply(lambda x: constraint_abs_wts(x))
        return weights

    def delever_weights(self,weights = None):
        if type(weights) not in [pd.DataFrame,pd.Series,np.array]:
            weights = self.weights
        abs_w =abs(weights).sum(axis = 1)
        def constraint_abs_w(weights):
            return weights/abs_w
        weights = weights.apply(lambda x: constraint_abs_w(x))
        return weights   

