import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize

class OptimPort:

    def __init__(self,raw_rets=None,er = None):
        '''
        OptimPort class takes in 2 inputs:
        1. raw_rets: This is the raw returns matrix with shape T*N, where T is the number of rows and N is the number of assets. This is the raw daily returns for the asset class
        2. er: This is our expected returns matrix
        The 2 matrices should be of the same shape
        '''
        self.raw_rets = raw_rets
        self.er = er
        if type(er) ==type(None):
            self.er = raw_rets
        if type(raw_rets) ==type(None):
            self.raw_rets = er

    def calc_port_rets(self,wts):
        '''
        This function calculates the mean returns per asset.
        Input parameters:
        1. wts: Refer to the exposure to each asset in our test
        '''
        wts = np.array (wts)
        return (self.er@wts).mean()

    def calc_port_sharpe(self,wts, freq=252):
        '''
        This function calculates the sharpe ratio of the portfolio.
        1. wts: Weights allocate to each asset
        2. freq: Refers to the periodicity at which we calculate returns
        '''
        rets = self.raw_rets@wts
        return ((rets-mean()/rets.std())*(freq**0.5))

    def calc_port_std(self,wts, cov=None, freq =252):
        '''
        This function calculates portfolio standard deviation
        Uses [weights transpose * covariance matrix * weights]
        1. cov: Desired covariance matrix, if None, we use the covariance matrix generated by the raw returns
        2. freq: Refers to the periodicity at which we calculate our returns
        '''
        wts = np. array(wts)
        wts = wts.reshape(wts.shape[0],1)
        if type(cov) !=pd.DataFrame:
            cov = self.raw_rets.cov()
        port_std = np.sqrt((wts.T@cov@wts).values[0])
        return port_std

    def get_msr_wts(self,cov=None, riskfree_rate = 0, exposure_constraint=1):
        n = self.raw_rets.shape[1]
        initial_guess = np.repeat(1/n,n)

        if exposure_constraint ==0:
            low_bnd,upp_bnd=-1,1
        elif exposure_constraint ==1:
            low_bnd,upp_bnd = 0,1
        elif exposure_constraint == 1:
            low_bnd, upp_bnd =-1,0
        else:
            low_bnd,upp_bnd = 0,1
        bounds = ((low_bnd,upp_bnd),)*n

        weights_constraint = {'type':'eq',
            'fun':lambda w: np.sum(w)-exposure_constraint
            }


        def neg_sharpe(w, er, cov,riskfree_rate):
            '''Returns the negative of the sharpe ratio of the given portfolio'''
            r = self.calc_port_rets(w)
            vol =self.calc_port_std(w, cov = cov)
            return -(r - riskfree_rate)/vol

        weights = minimize(neg_sharpe,initial_guess,args = (self.er,cov,riskfree_rate),
                            method = "SLSQP",
                            constraints =(weights_constraint),
                            bounds = bounds)

        if exposure_constraint==0 and (sum(weights.x)<-0.05 or sum(weights.x)>0.05 ):
            return np.repeat(0,n)
        return weights.x




class Implementation:
    '''
    The Implementation class incorporates adjustments and changes based on real-life portfolio implementation constraints.
    Class takes in our target position vector wts as its only input
    '''

    def __init__(self,weights):
        self.weights = weights

    def adjust_rebalance(self,threshold):

        prev = [0] *self.weights.shape[1]
        weights_cleaned = []
        for i in range(len(self.weights)):
            wts = []
            temp = self.weights.iloc[i].values
            for w_i in range(len(temp)):
                if abs(temp[w_i]-prev[w_i])>threshold:
                    wts.append(temp[w_i])
                else:
                    wts.append (prev[w_i])
            weights_cleaned.append(wts)
            prev = wts
        weights_cleaned = pd.DataFrame(weights_cleaned, index = self.weights.index, columns = self.weights.columns)
        return weights_cleaned

    def demean_and_delever_weights (self):
        mean_wts = self.weights.mean(axis=1)
        weights = self.weights.apply(lambda x: subtract_series(x))       
        def subtract_series(weights):
            return weights - mean_wts
        abs_w = abs(weights).sum(axis = 1) 
        def constraint_abs_wts(weights):
            return weights/abs_w
        weights = weights.apply(lambda x: constraint_abs_wts(x))
        return weights

    def delever_weights(self):
        abs_w =abs(self.weights).sum(axis = 1)
        def constraint_abs_w(weights):
            return weights/abs_w
        weights = self.weights.apply(lambda x: constraint_abs_w(x))
        return weights   